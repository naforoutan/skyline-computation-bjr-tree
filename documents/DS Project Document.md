### توضیح صورت پروژه
- نقاط skyline نقاطی هستند که در بررسی دو به دو نقاط با اون نقطه توی اون فاکتور‌ها (که تعداد اون‌ها بیانگر بعد هست) که داریم بررسیشون می‌کنیم حداقل در یک فاکتور از نقطه مقابل بهترن. یعنی مثلا فرض کن دو تا فاکتور قیمت و فاصله داریم (هر دو اگه کمتر باشن بهترن) و نقطه‌ای skyline هست که نقطه‌ دیگه‌ای نباشه که هم ازش ارزون‌تر باشه و هم نزدیک‌تر. (اگه نقطه a نسبت به نقطه b در همه فاکتورها بهتر باشه می‌گیم نقطه a نقطه b رو dominate می‌کنه)


### توضیح مقاله
- تو مقاله از یه BJR-tree استفاده می‌شه برای نگه داشتن روابط سلطه (dominance) و از یه nd-cache استفاده می‌شه برای نگه داشتن روابط قبلی سلطه تا از محاسبه دوباره در continuous skyline جلوگیری کنه.
- خب ماجرا اینه که ما یه سری نقاط داریم و می‌خوایم skylineاشون رو در بیاریم حالا چرا؟ چون معمولا این نقاط که در حاشیه جمیع نقاطن اطلاعات مهمی دارن. بعضی وقتا مجموعه نقاط ما پویاست پس ما باید از continuous skyline computation استفاده کنیم و به طور پیوسته نقاط skyline رو در بیاریم. اما چندتا نکته هست. نکته اول درمورد نقاط skyline توی فضاهای چند بعدیه که تعداد بعدشون زیاده، تو این فضاها skyline ratio هی بزرگتر می‌شه تا در نهایت اگه یک بشه یعنی علنا همه نقاط ما skyline هست که خیلی به دردمون نمی‌خوره. مورد بعدی اینه که کار زمان‌بری هست و ما هدفمون اینه مسئله بهینه‌سازی حل کنیم. چیو بهینه کنیم؟ زمان محاسبه و پیداکردن نقاط skyline رو (چون به طور پیوسته دارن محاسبه می‌شن)
- اصطلاح activation و deactivation یک نقطه یعنی اینکه نقطه وارد فضای نقاط بشه (activate) یا از اون فضا حذف بشه (deactivate)
- ما میام برا نقاط پتانسیل اینکه بتونن skyline بشن یا نه رو تعریف می‌کنیم. مثلا skyline potential خود نقاط skyline یکه. ما فرضمون اینه که نقاط در فضای نقاطمون به صورت یکسان پخش شدن پس طبیعیه که با داشتن این فرض، هرچه فضا (حجم) مورد بررسی بیشتر باشه تعداد نقاط مورد بررسی بیشتره. از طرفی هرچقدر نقطه‌ای باشه که توسط تعداد زیادی نقطه dominate بشه پس احتمال (پتانسیل) اینکه skyline بشه کمه. و ما می‌تونیم از این پتانسیل برای کم کردن مقایسه و محاسبات اضافی کمک بگیریم.
- روابط سلطه متعدی هستند پس می‌تونیم از این ویژگی هم استفاده کنیم. بدین شکل که یه درخت گنده فرض می‌کنیم برای روابط سلطه. و در این درخت هر گره والد گره فرزند را dominate می‌کند. BJR tree زیر درختی است از این درخت سلطه که از ریشه شروع می‌شه. هرچقدر به ریشه نزدیک‌تر باشیم skyline potential بیشتر می‌شه.
- سرعت محاسبات BJR tree به دو علت زیاده. یک اینکه سلسله‌مراتبیه و دو اینکه مستقل از بعد هست.
- درخت nd-cache در نقطه مقابل bjr tree هست و کامل‌کننده آن. چون رابط غیر سلطه‌ را نگه می‌دارد.
- در فضای نقاط نقاطی که در حاشیه مجموعه نقاط قرار دارند معمولا باارزش‌ترن و نقاط معمولی معمولا اونایی هستن که در نزدیکی میانگین یا میانه قرار دارن.

#### ‌‌BJR tree
- در درخت bjr tree هر گره نماینده یک نقطه و هر یال نماینده سلطه‌است بدین شکل که اگر یالی از a به b بره یعنی a نقطه b رو dominate می‌کنه. و اگه نقطه‌ای skyline باشد مستقیم به ریشه (نماینده نقطه مبدا است که همه نقاط را dominate می‌کند) وصل می‌شود و اگر نقطه‌ای skyline نباشد، یعنی حداقل یک نقطه وجود دارد که آن را dominate می‌کند و به یکی از این نقاط وصل می‌شود.
- طبق این تعریف ما برای یک مجموعه نقاط می‌توانیم تعداد مختلفی bjr tree داشته باشیم.
- اگر در bjr tree یالی از a به b وصل باشد یعنی حتما a نقطه b را dominate می‌کند ولی اگر a نقطه b را dominate کند لزوما در درخت یالی از a به b وصل نیست.
- به جز استفاده از bjr tree از یه سری راه‌حل‌های دیگه استفاده می‌شد مثلا مثل اینکه بیایم فضای نقاط به قسمت‌هایی تبدیل کنیم و بعد با مقایسه نقطه نسبت به گوشه‌های پارت‌ها (فاصله منهتن) بیایم سلطه رو بررسی کنیم. که چندین مشکل داره: ۱) مفهوم اصلی سلطه فهمیده نمی‌شه. ۲) در همین راستا فاصله منتهتن معیار درستی برای مقایسه نیست. ۳)‌ گوشه‌های زیر فضاها نقطه واقعی نیستن یک سری نقاط مجازین ۴) با افزایش بعد تعداد زیرفضاها به صورت نمایی زیاد می‌شه.
##### lazy strategy
- تو bjr tree معمولی ما بدون توجه به بالانس درخت فرزندان ریشه را بررسی می‌کنیم تا ببینیم رابطه سلظه چگونه برقرار است و این موجب این می‌شه که با توجه به اینکه کدوم گره اول بررسی می‌شه به طول درخت اضافه بشه. درحالی که توی lazy strategy با توجه به اینکه تعداد اولاد کدوم گره کمتر است پیش می‌ریم و به جای اینکه به طول درخت اضافه کنیم به عرض درخت اضافه می‌کنیم. یکی از دلایل اینکار این است که گره‌هایی که در سطوح بعدی درخت قرار می‌گرفتند skyline potential کمتری داشتند. این شکلی ما می‌تونیم گره‌هارو به روش بهتری بررسی کنیم.

#### ‌‌ND-Cache
- گاهی اوقات می‌شه که با اکتیو شدن یه سری نقاط اسکای‌لاین‌های جدید به وجود بیاد که با دی‌اکتیو شدن این نقاط جدید دوباره نقاط قبل اسکای‌لاین می‌شن. تو این موقعیت‌ها با نگه داشتن اطلاعات قبلی می‌تونیم از محاسبات دوباره جلوگیری کنیم.
- بنابراین میایم در یک کش این اطلاعات رو سیو می‌‌کنیم. بدین شکل که یه آرایه c داریم به طول n یا همون تعداد نقاط ما. اگر نقطه ei در زمان Tj اسکای‌لاین بود میایم بدین شکل آپدیت‌شده‌ترین اطلاعات رو سیو می‌کنیم: c[i] = Tj
- نحوه استفاده از این اطلاعات بدین شکله که مثلا می‌خوایم بگیم در فلان تایم آیا e3 نقطه e2 رو dominate می‌کنه یا نه. تو این موقعیت می‌ریم c[2] و c[3] رو بررسی می‌کنیم. اگه مقادیر یکسانی داشتند پس خیر همدیگرو dominate نمی‌کنند پس نیاز به محاسبه نیست.
- پس bjr tree اطلاعات dominance و nd-cache اطلاعات non-dominance را سیو می‌کند. بدین شکل که با بررسی اینکه کدام نقاط در یک زمان اسکای‌لاین بودند پس به طور قطع یکدیگر را dominate نمی‌کنند.
